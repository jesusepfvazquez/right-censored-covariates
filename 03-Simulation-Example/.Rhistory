scale_color_manual(labels = c("IPW", "MLE", "ACC",
expression("ACC with " * Lambda),
"MACC",
expression("MACC with " * Lambda),
"AIPW",
expression("AIPW with " * Lambda)),
values = c("#000000", "#E69F00", "#56B4E9",
"#009E73", "#F0E442", "#0072B2",
"#D55E00", "#CC79A7"))
p2
# save plot
ggsave(filename = "independent-efficiency.png",  width = 7, height = 9, dpi = 300, units = "in")
# generate data under dependent covariate right censoring
set.seed(0)
dep_censoring. = TRUE
dat = data_mvn(nSubjects = n, dep_censoring = dep_censoring.)
# visualize data
head(dat, 2) %>% paged_table()
# check bivariate correlations
dat %>% select(X,C,Z) %>% cor() %>% round(2)
# check partial correlation between (X,C) given Z
partial_cor = dat %>% select(X,C,Z) %>% ppcor::pcor()
partial_cor$estimate %>% round(2)
# Set up the plotting area to have 1 row and 2 columns
par(mfrow = c(1, 2))
# Histogram and density for X
hist(dat$X, probability = TRUE, main = "Histogram of X", xlab = "X")
x_mean <- mean(dat$X)
x_sd <- sd(dat$X)
curve(dnorm(x, mean = x_mean, sd = x_sd), add = TRUE, col = "blue", lwd = 2)
legend("topright", legend = paste("Mean =", round(x_mean, 2), "\nSD =", round(x_sd, 2)), bty = "n")
# Histogram and density for C
hist(dat$C, probability = TRUE, main = "Histogram of C", xlab = "C")
c_mean <- mean(dat$C)
c_sd <- sd(dat$C)
curve(dnorm(x, mean = c_mean, sd = c_sd), add = TRUE, col = "red", lwd = 2)
legend("topright", legend = paste("Mean =", round(c_mean, 2), "\nSD =", round(c_sd, 2)), bty = "n")
par(mfrow = c(1, 1)) # Reset the plotting parameters to default
# Set up the plotting area to have 1 row and 2 columns
par(mfrow = c(1, 1))
# scatter plot for pi(w,z)
dat %>%
mutate(D = factor(D, levels = c("0", "1"), labels = c("Right-censored", "Observed"))) %>%
ggplot(aes(x= W ,y=myp_xz, colour =D)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Scatter plot of \u03C0(w,z) vs. W", y = "\u03C0(w,z)", x = "W", colour = "") +
theme(legend.position="bottom")
# Set up the plotting area to have 1 row and 2 columns
par(mfrow = c(1, 2))
# Histogram and density for X
hist(dat$X, probability = TRUE, main = "Histogram of X", xlab = "X")
x_mean <- mean(dat$X)
x_sd <- sd(dat$X)
curve(dnorm(x, mean = x_mean, sd = x_sd), add = TRUE, col = "blue", lwd = 2)
legend("topright", legend = paste("Mean =", round(x_mean, 2), "\nSD =", round(x_sd, 2)), bty = "n")
# Histogram and density for C
hist(dat$C, probability = TRUE, main = "Histogram of C", xlab = "C")
c_mean <- mean(dat$C)
c_sd <- sd(dat$C)
curve(dnorm(x, mean = c_mean, sd = c_sd), add = TRUE, col = "red", lwd = 2)
legend("topright", legend = paste("Mean =", round(c_mean, 2), "\nSD =", round(c_sd, 2)), bty = "n")
par(mfrow = c(1, 1)) # Reset the plotting parameters to default
# Set up the plotting area to have 1 row and 2 columns
par(mfrow = c(1, 1))
# scatter plot for pi(w,z)
dat %>%
mutate(D = factor(D, levels = c("0", "1"), labels = c("Right-censored", "Observed"))) %>%
ggplot(aes(x= W ,y=myp_xz, colour =D)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Scatter plot of \u03C0(w,z) vs. W", y = "\u03C0(w,z)", x = "W", colour = "") +
theme(legend.position="bottom")
round(cor(dat$myp_xz, dat$myp_yz), 2)
# scatter plot for pi(y,z)
dat %>%
mutate(D = factor(D, levels = c("0", "1"), labels = c("Right-censored", "Observed"))) %>%
ggplot(aes(x= myp_xz ,y=myp_yz, colour =D)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Scatter plot of \u03C0(w,z) vs. \u03C0(y,z)", y = "\u03C0(y,z)", x = "\u03C0(w,z)",  colour = "") +
theme(legend.position="bottom")
# scatter plot for pi(y,z)
dat %>%
mutate(D = factor(D, levels = c("0", "1"), labels = c("Right-censored", "Observed"))) %>%
ggplot(aes(x= myp_xz ,y=myp_yz, colour =D)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Scatter plot of \u03C0(w,z) vs. \u03C0(y,z)", y = "\u03C0(y,z)", x = "\u03C0(w,z)",  colour = "") +
theme(legend.position="bottom")
# Load files from Dependent folder
# Sample size 100
list_est <- list.files(path = paste0("../01-Data/Known nuisance parameters/Dependent/100-V3"), pattern = "est_results*", full.names = T)
myresults_a = readmysims(list_est, 100)
# Sample size 300
list_est <- list.files(path = paste0("../01-Data/Known nuisance parameters/Dependent/300-V3"), pattern = "est_results*", full.names = T)
myresults_b = readmysims(list_est, 300)
# Sample size 1000
list_est <- list.files(path = paste0("../01-Data/Known nuisance parameters/Dependent/1000-V3"), pattern = "est_results*", full.names = T)
myresults_c = readmysims(list_est, 1000)
# combine and format
myresults = rbind(myresults_a, myresults_b, myresults_c) %>%
data.frame() %>%
mutate(Method =
factor(Method,
levels = c("oracle", "cc", "naive",
"ipw", "ipw-w" , "ipw-hat", "ipw-yz",
"acc","acc-eta1", "acc-w","acc-eta1-w", "acc-lambda", "acc-lambda-hat", "acc-lambda-eta1", "acc-lambda-w",  "acc-lambda-eta1-w",
"macc","macc-eta1", "macc-w","macc-eta1-w", "macc-lambda", "macc-lambda-hat", "macc-lambda-eta1", "macc-lambda-w",  "macc-lambda-eta1-w",
"aipw", "aipw-eta1", "aipw-w", "aipw-eta1-w" ,"aipw-lambda", "aipw-lambda-hat","aipw-lambda-eta1", "aipw-lambda-w","aipw-lambda-eta1-w",
"mle", "mle-w"))) %>%
mutate(Method.c = ifelse(Method %in% c("ipw", "ipw-w" , "ipw-hat", "ipw-yz"), "ipw",
ifelse(Method %in% c("aipw", "aipw-eta1", "aipw-w", "aipw-eta1-w" ,"aipw-lambda", "aipw-lambda-hat","aipw-lambda-eta1", "aipw-lambda-w","aipw-lambda-eta1-w"), "aipw",
ifelse(Method %in% c("acc","acc-eta1", "acc-w","acc-eta1-w", "acc-lambda", "acc-lambda-hat", "acc-lambda-eta1", "acc-lambda-w",  "acc-lambda-eta1-w"), "acc",
ifelse(Method %in% c("macc","macc-eta1", "macc-w","macc-eta1-w", "macc-lambda", "macc-lambda-hat", "macc-lambda-eta1", "macc-lambda-w",  "macc-lambda-eta1-w"), "macc",
ifelse(Method %in% c("mle","mle-w"), "mle",
ifelse(Method == "oracle", "oracle",
ifelse(Method == "cc", "cc", "naive")) )) )))) %>%
mutate(Method.c = ifelse(Method == "naive", "naive", Method.c)) %>%
mutate(Method.c = factor(Method.c, levels = c("oracle", "cc", "ipw", "acc", "macc", "aipw","mle") ))
myresults = myresults %>%
mutate(beta0.x = as.numeric(beta0.x),
beta1.x = as.numeric(beta1.x),
beta2.x = as.numeric(beta2.x),
sigma.x = as.numeric(sigma.x),
beta0.y = as.numeric(beta0.y),
beta1.y = as.numeric(beta1.y),
beta2.y = as.numeric(beta2.y)) %>%
# subset only those simulations that
filter(abs(beta0.x-theta[1])/theta[1] < est_threshold &
abs(beta1.x-theta[2])/theta[2] < est_threshold &
abs(beta2.x-theta[3])/theta[3] < est_threshold &
abs(sigma.x-theta[4])/theta[4] < est_threshold) %>%
na.omit()
# Calculate bias
myresults$beta0_coverage <- ((myresults$beta0.x + qnorm(0.975)*myresults$beta0.y) >= theta[1]) &
((myresults$beta0.x - qnorm(0.975)*myresults$beta0.y) <= theta[1])
myresults$beta1_coverage <- ((myresults$beta1.x + qnorm(0.975)*myresults$beta1.y) >= theta[2]) &
((myresults$beta1.x - qnorm(0.975)*myresults$beta1.y) <= theta[2])
myresults$beta2_coverage <- ((myresults$beta2.x + qnorm(0.975)*myresults$beta2.y) >= theta[3]) &
((myresults$beta2.x - qnorm(0.975)*myresults$beta2.y) <= theta[3])
# mean estimates
myresults_est = myresults %>%
dplyr::select(Method,n,beta0.x, beta1.x, beta2.x, sigma.x) %>%
group_by(Method, n) %>%
summarise_all(function(x) mean(as.numeric(x)) %>% round(2))
myresults_est %>% paged_table()
# mean SE
myresults_se = myresults %>%
dplyr::select(Method,n,beta0.y, beta1.y, beta2.y) %>%
group_by(Method,n) %>%
summarise_all(function(x) mean(as.numeric(x)*100) %>% round(2))
myresults_se  %>% paged_table()
# empirical SE
myresults_sehat = myresults %>%
dplyr::select(Method,n,beta0.x, beta1.x, beta2.x, sigma.x) %>%
group_by(Method,n) %>%
summarise_all(function(x) round(100*var(as.numeric(x))^0.5, 5) %>% round(2))
myresults_sehat  %>% paged_table()
# coverage probabilities
myresults_coverage = myresults %>%
dplyr::select(Method,n, beta0_coverage, beta1_coverage, beta2_coverage) %>%
mutate(beta0_coverage = ifelse(beta0_coverage, 1, 0),
beta1_coverage = ifelse(beta1_coverage, 1, 0),
beta2_coverage = ifelse(beta2_coverage, 1, 0)) %>%
group_by(Method,n) %>%
summarise_all(function(x) round(mean(x)*100,2))
myresults_coverage  %>% paged_table()
## efficiency plots
# empirical SE
cc_sehat <- myresults %>%
subset(Method %in% c("cc")) %>%
dplyr::select(Method, n, beta0.x, beta1.x, beta2.x) %>%
reshape2::melt(id.vars = c("Method", "n"), variable.name = c("Parameter")) %>%
group_by(Method, n, Parameter) %>%
summarise(se_cc = var(value)^0.5, .groups = "drop")
aug_sehat = myresults %>%
subset(Method %in% c("acc","acc-lambda", "macc", "macc-lambda", "aipw", "aipw-lambda", "ipw", "mle")) %>%
dplyr::select(Method, n, beta0.x, beta1.x, beta2.x) %>%
reshape2::melt(id.vars = c("Method", "n"), variable.name = c("Parameter")) %>%
group_by(Method, n, Parameter) %>%
summarise(se_aug = var(value)^0.5, .groups = "drop")
emp_sehat = left_join(aug_sehat, cc_sehat, by = c("n", "Parameter")) %>%
mutate(myratio = se_aug/se_cc) %>%
mutate(type = "Empirical SE")
## mean SE
cc_sehat <- myresults %>%
subset(Method %in% c("cc")) %>%
dplyr::select(Method, n, beta0.y, beta1.y, beta2.y) %>%
reshape2::melt(id.vars = c("Method", "n"), variable.name = c("Parameter")) %>%
group_by(Method, n, Parameter) %>%
summarise(se_cc = mean(value), .groups = "drop")
aug_sehat = myresults %>%
subset(Method %in% c("acc","acc-lambda", "macc", "macc-lambda", "aipw", "aipw-lambda", "ipw", "mle")) %>%
dplyr::select(Method, n, beta0.y, beta1.y, beta2.y) %>%
reshape2::melt(id.vars = c("Method", "n"), variable.name = c("Parameter")) %>%
group_by(Method, n, Parameter) %>%
summarise(se_aug = mean(value), .groups = "drop")
mean_sehat = left_join(aug_sehat, cc_sehat, by = c("n", "Parameter")) %>%
mutate(myratio = se_aug/se_cc) %>%
mutate(type = "Mean SE")
colnames(mean_sehat) = colnames(emp_sehat)
myresults_sehat = rbind(mean_sehat, emp_sehat) %>%
mutate(Method.x = factor(Method.x, levels = c("ipw","mle","acc", "acc-lambda", "macc", "macc-lambda" , "aipw", "aipw-lambda"))) %>%
mutate(Parameter = ifelse(Parameter %in% c("beta0.y","beta0.x"), "beta0", ifelse(Parameter %in% c("beta1.y", "beta1.x"), "beta1", "beta2")))
p3 <- myresults %>%
subset(Method.c %in% c("cc","acc", "macc", "ipw", "aipw", "mle")) %>%
select(Method, Method.c, beta0.x, beta1.x, beta2.x, n) %>%
reshape2::melt(id.vars = c("Method", "Method.c", "n"), variable.name = c("Parameter")) %>%
mutate(Parameter = factor(Parameter, levels = c("beta0.x", "beta2.x", "beta1.x"))) %>%
subset(Method != "mle-w" & n =="1000") %>%
mutate(Method = factor(Method, labels = c("CC", "IPW", "IPW, incorrect \u03C0(w,z)", "IPW, correct \u03C0(y,z)",
"ACC", "ACC, incorrect \u03a8(y,z)", "ACC, incorrect \u03C0(y,z)", "ACC, incorrect \u03C0(y,z) and \u03a8(y,z)", "ACC with \u039b", "ACC with \u039b, incorrect \u03C0(y,z)",
"MACC", "MACC, incorrect \u03a8(y,z)", "MACC, , incorrect \u03C0(w,z)", "MACC, incorrect \u03C0(w,z) and \u03a8(y,z)", "MACC with \u039b", "MACC with \u039b, incorrect \u03C0(w,z)",
"AIPW", "AIPW, incorrect \u03a8(y,z)", "AIPW, , incorrect \u03C0(w,z)", "AIPW, incorrect \u03C0(w,z) and \u03a8(y,z)", "AIPW with \u039b", "AIPW with \u039b, incorrect \u03C0(w,z)", "MLE"))) %>%
ggplot(aes(y=value, x=Method, fill=Method.c)) +
geom_boxplot(outlier.color = "black", outlier.size = 0.2, position=position_dodge(.9)) +
stat_summary(fun=mean, colour="white", geom="point", shape=18, size=2, position=position_dodge(.9)) +
facet_grid(scales = "free",
#cols = vars(n),
rows = vars(Parameter),
labeller = labeller(Parameter = c(beta0.x = "Intercept: \u03B2\u2080=1",
beta2.x = "A-X: \u03B2\u2081=3",
beta1.x = "Z: \u03B2\u2082=2"),
type = c("Emprical SE", "Mean SE"))) +  # or any other appropriate label for `type`
geom_hline(data = . %>% filter(Parameter == "beta0.x"), aes(yintercept = 1), linetype = "dashed", color = "red") +
geom_hline(data = . %>% filter(Parameter == "beta2.x"), aes(yintercept = 3), linetype = "dashed", color = "red") +
geom_hline(data = . %>% filter(Parameter == "beta1.x"), aes(yintercept = 2), linetype = "dashed", color = "red") +
theme_bw() + theme(legend.position="bottom") +
theme(axis.text.x = element_text(angle = 70, vjust = 1, hjust=1, size = 10),
legend.text.align = 0,
axis.text.y = element_text(size=12)) +
guides(fill=guide_legend(nrow=1)) +
labs(x = "", y = TeX("Estimate"), fill = "Estimator", title = "Distribution of simulation results under dependent covariate right-censoring") +
scale_fill_manual(labels = c("CC", "IPW", "ACC", "MACC", "AIPW", "MLE"),
values = c("#000000","#E69F00","#56B4E9","#009E73",
"#F0E442", "#0072B2"))
p3
# save plot
ggsave(filename = "dependent-boxplots-combined.png",  width = 8, height = 9, dpi = 300, units = "in")
p4 <- myresults_sehat %>%
mutate(Parameter = factor(Parameter, levels = c("beta0", "beta2", "beta1"))) %>%
ggplot(aes(x=n, y=myratio, color=Method.x)) +
geom_point(size=2) +
geom_line(linewidth = 1) +
geom_hline(yintercept = 1, linetype = "dashed", color = "red") +
facet_grid(cols = vars(type),
rows = vars(Parameter),
labeller = labeller(Parameter = c(beta0 = "Intercept: \u03B2\u2080",
beta2 = "A-X: \u03B2\u2081",
beta1 = "Z: \u03B2\u2082"),
type = c("Emprical SE", "Mean SE"))) +  # or any other appropriate label for `type`
theme_bw() +
theme(legend.position = "bottom") +
labs(title = "Efficiency comparative of estimators with the CC estimator for \ndependent covariate right-censoring",
y = expression("Efficiency Ratio (%) = " * SE[Method] / SE[CC]),
color = "Estimator",
x = "Sample size (n)") +
scale_y_continuous(labels = scales::percent_format()) +
scale_x_continuous(breaks = unique(myresults_sehat$n)) +
guides(color = guide_legend(nrow = 2)) +
scale_color_manual(labels = c("IPW", "MLE", "ACC",
expression("ACC with " * Lambda),
"MACC",
expression("MACC with " * Lambda),
"AIPW",
expression("AIPW with " * Lambda)),
values = c("#000000", "#E69F00", "#56B4E9",
"#009E73", "#F0E442", "#0072B2",
"#D55E00", "#CC79A7"))
p2
# save plot
ggsave(filename = "dependent-efficiency.png",  width = 7, height = 9, dpi = 300, units = "in")
# generate data under independent covariate right censoring
set.seed(0)
dep_censoring. = FALSE
dat = data_mvn(nSubjects = n, dep_censoring = dep_censoring.)
logLik_noninf = function(myalpha, mydata){
# density function
cxz_likelihood = function(w,delta,z){
# 1. build my own bivariate density f(x,c|z)
mydmvnorm = function(xzc){
# need these for integration components
meanXZ = myalpha[1] + myalpha[2]*xzc[2]
meanCZ = myalpha[3] + myalpha[4]*xzc[2]
sdXZ = myalpha[5]
sdCZ = myalpha[6]
val = dnorm(xzc[1], mean = meanXZ, sd = sdXZ)*
dnorm(xzc[3], mean = meanCZ, sd = sdCZ) # C|X,Z
return(val)
}
# 2. Integrate components of X and C that are missing
dmvnorm_delta1 = function(t) unlist(lapply(t, function(tt) mydmvnorm(c(w,z,tt))))
dmvnorm_delta0 = function(t) unlist(lapply(t, function(tt) mydmvnorm(c(tt,z,w))))
mydensity = ifelse(delta==1,
integrate(dmvnorm_delta1,lower = w, upper = Inf)$value,
integrate(dmvnorm_delta0,lower = w, upper = Inf)$value)
return(mydensity)
}
# integrate the density function above
myreturn = lapply(1:nrow(mydata),
function(tt) cxz_likelihood(mydata$W[tt], mydata$D[tt], mydata$Z[tt])) %>%
unlist() %>% log() %>% sum()
return(myreturn)
}
# select values close to the oracle values:
g1 = c(0,0.5,0,0.5,0.86,1.94) + 0.1
myoptim1 = optimx(
par = g1, # initial values for the parameters.
fn = function(x,X){logLik_noninf(myalpha = x,mydata = X)}, # log likelihood
X = dat,
method = "Nelder-Mead",
control = list(
trace = F, # higher number print more detailed output
maximize = T, # default is to minimize
abstol= 10^(-4)
)
)
# print estimates
myalpha1 = unlist(myoptim1[1:6])
myalpha1
# calculate the probability of X being observed
myp = function(myalpha,data){
meanCZ = myalpha[3] + myalpha[4]*dat$Z
sdCZ = myalpha[6]
myphat = pnorm(data$W, mean = meanCZ, sd = sdCZ, lower.tail = FALSE)
return(myphat)
}
dat$myp_xz_mle = myp(myalpha1,dat)
# scatter plot of oracle vs estimated probabilities
dat %>%
mutate(D = factor(D, levels = c("0", "1"), labels = c("Right-censored", "Observed"))) %>%
ggplot(aes(x= myp_xz_mle ,y=myp_xz, colour =D)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Scatter plot of oracle vs. estimated \u03C0(w,z) ", y = "oracle", x = "estimated", colour = "") +
theme(legend.position="bottom")
# calculate the probability of X being observed
myp = function(myalpha,data){
meanCZ = myalpha[3] + myalpha[4]*dat$Z
sdCZ = myalpha[6]
myphat = pnorm(data$W, mean = meanCZ, sd = sdCZ, lower.tail = FALSE)
return(myphat)
}
dat$myp_xz_mle = myp(myalpha1,dat)
# scatter plot of oracle vs estimated probabilities
dat %>%
mutate(D = factor(D, levels = c("0", "1"), labels = c("Right-censored", "Observed"))) %>%
ggplot(aes(x= myp_xz_mle ,y=myp_xz, colour =D)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Scatter plot of oracle vs. estimated \u03C0(w,z) ", y = "oracle", x = "estimated", colour = "") +
theme(legend.position="bottom")
round(cor(dat$myp_xz_mle[dat$D==1], dat$myp_xz[dat$D==1]),2)
round(cor(dat$myp_xz_mle[dat$D==1], dat$myp_xz[dat$D==1]),4)
# oracle X|Z values
dat$meanXZ = 0 + 0.5/1*(dat$Z-0) # mu_x + (var_xz/var_z)*(data.$Z-mu_z)
#estimated X|Z values
dat$meanXZ_hat = myalpha1[1] + myalpha1[2]*dat$Z
# scatter plot of oracle vs estimated probabilities
dat %>%
ggplot(aes(x= meanXZ_hat ,y=meanXZ))+
geom_point() +
labs(title = "Scatter plot of oracle vs. estimated \nvalues of X conditional on Z ", x = "Estimated", y = "Oracle", colour = "") +
ylim(-2,2) + xlim(-2,2)
myp_yz.b = function(myalpha, data){
meanXZ = myalpha[1] + myalpha[2]*data$Z
sdXZ = myalpha[5]
meanCZ = myalpha[3] + myalpha[4]*data$Z
sdCZ = myalpha[6]
integral_func_num.b = function(t){
val = rep(NA, length(t))
for (i in 1:length(t)){
myp = pnorm(t[i], mean = meanCZ, sd = sdCZ, lower.tail = FALSE)
val[i] = myp*
dnorm(data$y -  cbind(1,data$Z,data$A - t[i])%*%theta[1:3], 0, sd = theta[4])*
dnorm(t[i], mean = meanXZ, sd = sdXZ)
}
return(val)
}
myp_yz_num = integrate(integral_func_num.b, lower = -Inf, upper = Inf,
rel.tol = 1e-7, abs.tol = 1e-7)$value
integral_func_denom.b = function(t){
val = rep(NA, length(t))
for (i in 1:length(t)){
val[i] = dnorm(data$y -  cbind(1,data$Z,data$A - t[i])%*%theta[1:3], 0, sd = theta[4])*
dnorm(t[i], mean = meanXZ, sd = sdXZ)
}
return(val)
}
myp_yz_denom = integrate(integral_func_denom.b, lower = -Inf, upper = Inf, rel.tol = 1e-7, abs.tol = 1e-7)$value
return(myp_yz_num/myp_yz_denom)
}
dat$myp_yz_est = lapply(1:nrow(dat), function(t.) myp_yz.b(myalpha1,dat[t.,])) %>% unlist()
# scatter plot of oracle vs estimated probabilities
dat %>%
ggplot(aes(x= myp_yz_est ,y=myp_yz))+
geom_point() +
labs(title = "Scatter plot of oracle vs. estimated probabilities \u03C0(y,z) ", x = "Estimated", y = "Oracle") +
theme(legend.position="bottom")
# Load files from Dependent folder
# Sample size 100
list_est <- list.files(path = paste0("../01-Data/Estimated nuisance parameters/Independent/1000-Lambda-hat"), pattern = "est_results*", full.names = T)
myresults_a = readmysims(list_est, 1000)
myresults_a = myresults_a %>%
subset(Method %in% c("oracle","cc", "naive", "ipw-hat", "acc-lambda-hat", "aipw-lambda-hat")) %>%
mutate(Method = ifelse(Method == "acc-lambda-hat", "macc-lambda", Method)) %>%
mutate(Method = ifelse(Method == "aipw-lambda-hat", "aipw-lambda", Method)) %>%
mutate(Method = ifelse(Method == "ipw-hat", "ipw", Method))
list_est <- list.files(path = paste0("../01-Data/Estimated nuisance parameters/Independent/1000-MLE-hat"), pattern = "est_results*", full.names = T)
myresults_b = readmysims(list_est, 1000)
myresults_b = myresults_b %>%subset(Method == "mle")
# combine and format
myresults = rbind(myresults_a, myresults_b) %>%
mutate(Method = factor(Method, levels = c("oracle", "cc", "naive", "ipw", "macc-lambda", "aipw-lambda", "mle")))
myresults = myresults %>%
mutate(beta0.x = as.numeric(beta0.x),
beta1.x = as.numeric(beta1.x),
beta2.x = as.numeric(beta2.x),
sigma.x = as.numeric(sigma.x),
beta0.y = as.numeric(beta0.y),
beta1.y = as.numeric(beta1.y),
beta2.y = as.numeric(beta2.y)) %>%
# subset only those simulations that
filter(abs(beta0.x-theta[1])/theta[1] < est_threshold &
abs(beta1.x-theta[2])/theta[2] < est_threshold &
abs(beta2.x-theta[3])/theta[3] < est_threshold &
abs(sigma.x-theta[4])/theta[4] < est_threshold) %>%
na.omit()
# Calculate bias
myresults$beta0_coverage <- ((myresults$beta0.x + qnorm(0.975)*myresults$beta0.y) >= theta[1]) &
((myresults$beta0.x - qnorm(0.975)*myresults$beta0.y) <= theta[1])
myresults$beta1_coverage <- ((myresults$beta1.x + qnorm(0.975)*myresults$beta1.y) >= theta[2]) &
((myresults$beta1.x - qnorm(0.975)*myresults$beta1.y) <= theta[2])
myresults$beta2_coverage <- ((myresults$beta2.x + qnorm(0.975)*myresults$beta2.y) >= theta[3]) &
((myresults$beta2.x - qnorm(0.975)*myresults$beta2.y) <= theta[3])
# mean estimates
myresults_est = myresults %>%
dplyr::select(Method,n,beta0.x, beta1.x, beta2.x, sigma.x) %>%
group_by(Method, n) %>%
summarise_all(function(x) mean(as.numeric(x)) %>% round(2))
myresults_est %>% paged_table()
# mean SE
myresults_se = myresults %>%
dplyr::select(Method,n,beta0.y, beta1.y, beta2.y) %>%
group_by(Method,n) %>%
summarise_all(function(x) mean(as.numeric(x)*100) %>% round(2))
myresults_se  %>% paged_table()
# empirical SE
myresults_sehat = myresults %>%
dplyr::select(Method,n,beta0.x, beta1.x, beta2.x, sigma.x) %>%
group_by(Method,n) %>%
summarise_all(function(x) round(100*var(as.numeric(x))^0.5, 5) %>% round(2))
myresults_sehat  %>% paged_table()
# coverage probabilities
myresults_coverage = myresults %>%
dplyr::select(Method,n, beta0_coverage, beta1_coverage, beta2_coverage) %>%
mutate(beta0_coverage = ifelse(beta0_coverage, 1, 0),
beta1_coverage = ifelse(beta1_coverage, 1, 0),
beta2_coverage = ifelse(beta2_coverage, 1, 0)) %>%
group_by(Method,n) %>%
summarise_all(function(x) round(mean(x)*100,2))
myresults_coverage  %>% paged_table()
p5 <- myresults %>%
subset(Method %in% c("cc", "macc-lambda", "ipw", "aipw-lambda", "mle")) %>%
select(Method, beta0.x, beta1.x, beta2.x) %>%
reshape2::melt(id.vars = c("Method"), variable.name = c("Parameter")) %>%
mutate(Parameter = factor(Parameter, levels = c("beta0.x", "beta2.x", "beta1.x"))) %>%
mutate(Method = factor(Method, labels = c("CC", "IPW", "MACC with \u039b", "AIPW with \u039b", "MLE"))) %>%
ggplot(aes(y=value, x=Method, fill=Method)) +
geom_boxplot(outlier.color = "black", outlier.size = 0.2, position=position_dodge(.9)) +
stat_summary(fun=mean, colour="white", geom="point", shape=18, size=2, position=position_dodge(.9)) +
facet_grid(scales = "free",
rows = vars(Parameter),
labeller = labeller(Parameter = c(beta0.x = "Intercept: \u03B2\u2080=1",
beta2.x = "A-X: \u03B2\u2081=3",
beta1.x = "Z: \u03B2\u2082=2"),
type = c("Emprical SE", "Mean SE"))) +  # or any other appropriate label for `type`
geom_hline(data = . %>% filter(Parameter == "beta0.x"), aes(yintercept = 1), linetype = "dashed", color = "red") +
geom_hline(data = . %>% filter(Parameter == "beta2.x"), aes(yintercept = 3), linetype = "dashed", color = "red") +
geom_hline(data = . %>% filter(Parameter == "beta1.x"), aes(yintercept = 2), linetype = "dashed", color = "red") +
theme_bw() + theme(legend.position="bottom") +
theme(axis.text.x = element_text(angle = 70, vjust = 1, hjust=1, size = 10),
legend.text.align = 0,
axis.text.y = element_text(size=12)) +
guides(fill=guide_legend(nrow=1)) +
labs(x = "", y = TeX("Estimate"), fill = "Estimator", title = "Distribution of simulation results under dependent covariate right-censoring") +
scale_fill_manual(labels = c("CC", "IPW", "MACC", "AIPW", "MLE"),
values = c("#000000","#E69F00","#009E73",
"#F0E442", "#0072B2"))
p5
# save plot
ggsave(filename = "dependent-boxplots-combined-estimated.png",  width = 8, height = 9, dpi = 300, units = "in")
# generate data under independent covariate right censoring
set.seed(0)
dep_censoring. = FALSE
dat = data_mvn_bartlette(nSubjects = n)
head(dat) %>% paged_table()
glm(formula = D ~ y + Z, family = binomial(link = "logit"), data = dat)
dat %>%
mutate(D = factor(D, levels = c("0", "1"), labels = c("Right-censored", "Observed"))) %>%
ggplot(aes(x=Z ,y=y, colour =myp_yz)) +
geom_point() +
labs(title = "Scatter plot of Y vs. Z", y = "y", x = "Z", colour = "Probability \u03C0(y,z)") +
theme(legend.position="bottom")
dat %>%
mutate(D = factor(D, levels = c("0", "1"), labels = c("Right-censored", "Observed"))) %>%
ggplot(aes(x=Z ,y=y, colour =myp_yz)) +
geom_point() +
theme_minimal() +
labs(title = "Scatter plot of Y vs. Z", y = "y", x = "Z", colour = "Probability \u03C0(y,z)") +
theme(legend.position="bottom")
